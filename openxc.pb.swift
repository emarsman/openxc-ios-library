// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: openxc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Openxc_VehicleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Openxc_VehicleMessage.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var canMessage: Openxc_CanMessage {
    get {return _storage._canMessage ?? Openxc_CanMessage()}
    set {_uniqueStorage()._canMessage = newValue}
  }
  /// Returns true if `canMessage` has been explicitly set.
  var hasCanMessage: Bool {return _storage._canMessage != nil}
  /// Clears the value of `canMessage`. Subsequent reads from it will return its default value.
  mutating func clearCanMessage() {_uniqueStorage()._canMessage = nil}

  var simpleMessage: Openxc_SimpleMessage {
    get {return _storage._simpleMessage ?? Openxc_SimpleMessage()}
    set {_uniqueStorage()._simpleMessage = newValue}
  }
  /// Returns true if `simpleMessage` has been explicitly set.
  var hasSimpleMessage: Bool {return _storage._simpleMessage != nil}
  /// Clears the value of `simpleMessage`. Subsequent reads from it will return its default value.
  mutating func clearSimpleMessage() {_uniqueStorage()._simpleMessage = nil}

  var diagnosticResponse: Openxc_DiagnosticResponse {
    get {return _storage._diagnosticResponse ?? Openxc_DiagnosticResponse()}
    set {_uniqueStorage()._diagnosticResponse = newValue}
  }
  /// Returns true if `diagnosticResponse` has been explicitly set.
  var hasDiagnosticResponse: Bool {return _storage._diagnosticResponse != nil}
  /// Clears the value of `diagnosticResponse`. Subsequent reads from it will return its default value.
  mutating func clearDiagnosticResponse() {_uniqueStorage()._diagnosticResponse = nil}

  var controlCommand: Openxc_ControlCommand {
    get {return _storage._controlCommand ?? Openxc_ControlCommand()}
    set {_uniqueStorage()._controlCommand = newValue}
  }
  /// Returns true if `controlCommand` has been explicitly set.
  var hasControlCommand: Bool {return _storage._controlCommand != nil}
  /// Clears the value of `controlCommand`. Subsequent reads from it will return its default value.
  mutating func clearControlCommand() {_uniqueStorage()._controlCommand = nil}

  var commandResponse: Openxc_CommandResponse {
    get {return _storage._commandResponse ?? Openxc_CommandResponse()}
    set {_uniqueStorage()._commandResponse = newValue}
  }
  /// Returns true if `commandResponse` has been explicitly set.
  var hasCommandResponse: Bool {return _storage._commandResponse != nil}
  /// Clears the value of `commandResponse`. Subsequent reads from it will return its default value.
  mutating func clearCommandResponse() {_uniqueStorage()._commandResponse = nil}

  var diagnosticStitchResponse: Openxc_DiagnosticStitchResponse {
    get {return _storage._diagnosticStitchResponse ?? Openxc_DiagnosticStitchResponse()}
    set {_uniqueStorage()._diagnosticStitchResponse = newValue}
  }
  /// Returns true if `diagnosticStitchResponse` has been explicitly set.
  var hasDiagnosticStitchResponse: Bool {return _storage._diagnosticStitchResponse != nil}
  /// Clears the value of `diagnosticStitchResponse`. Subsequent reads from it will return its default value.
  mutating func clearDiagnosticStitchResponse() {_uniqueStorage()._diagnosticStitchResponse = nil}

  var timestamp: UInt64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unused // = 0
    case can // = 1
    case simple // = 2
    case diagnostic // = 3
    case controlCommand // = 4
    case commandResponse // = 5
    case diagnosticStitch // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unused
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unused
      case 1: self = .can
      case 2: self = .simple
      case 3: self = .diagnostic
      case 4: self = .controlCommand
      case 5: self = .commandResponse
      case 6: self = .diagnosticStitch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unused: return 0
      case .can: return 1
      case .simple: return 2
      case .diagnostic: return 3
      case .controlCommand: return 4
      case .commandResponse: return 5
      case .diagnosticStitch: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Openxc_VehicleMessage.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_VehicleMessage.TypeEnum] = [
    .unused,
    .can,
    .simple,
    .diagnostic,
    .controlCommand,
    .commandResponse,
    .diagnosticStitch,
  ]
}

#endif  // swift(>=4.2)

struct Openxc_CanMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bus: Int32 = 0

  var id: UInt32 = 0

  var data: Data = Data()

  var frameFormat: Openxc_CanMessage.FrameFormat = .unused

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FrameFormat: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unused // = 0
    case standard // = 1
    case extended // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unused
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unused
      case 1: self = .standard
      case 2: self = .extended
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unused: return 0
      case .standard: return 1
      case .extended: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Openxc_CanMessage.FrameFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_CanMessage.FrameFormat] = [
    .unused,
    .standard,
    .extended,
  ]
}

#endif  // swift(>=4.2)

struct Openxc_ControlCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Openxc_ControlCommand.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  var diagnosticRequest: Openxc_DiagnosticControlCommand {
    get {return _storage._diagnosticRequest ?? Openxc_DiagnosticControlCommand()}
    set {_uniqueStorage()._diagnosticRequest = newValue}
  }
  /// Returns true if `diagnosticRequest` has been explicitly set.
  var hasDiagnosticRequest: Bool {return _storage._diagnosticRequest != nil}
  /// Clears the value of `diagnosticRequest`. Subsequent reads from it will return its default value.
  mutating func clearDiagnosticRequest() {_uniqueStorage()._diagnosticRequest = nil}

  var passthroughModeRequest: Openxc_PassthroughModeControlCommand {
    get {return _storage._passthroughModeRequest ?? Openxc_PassthroughModeControlCommand()}
    set {_uniqueStorage()._passthroughModeRequest = newValue}
  }
  /// Returns true if `passthroughModeRequest` has been explicitly set.
  var hasPassthroughModeRequest: Bool {return _storage._passthroughModeRequest != nil}
  /// Clears the value of `passthroughModeRequest`. Subsequent reads from it will return its default value.
  mutating func clearPassthroughModeRequest() {_uniqueStorage()._passthroughModeRequest = nil}

  var acceptanceFilterBypassCommand: Openxc_AcceptanceFilterBypassCommand {
    get {return _storage._acceptanceFilterBypassCommand ?? Openxc_AcceptanceFilterBypassCommand()}
    set {_uniqueStorage()._acceptanceFilterBypassCommand = newValue}
  }
  /// Returns true if `acceptanceFilterBypassCommand` has been explicitly set.
  var hasAcceptanceFilterBypassCommand: Bool {return _storage._acceptanceFilterBypassCommand != nil}
  /// Clears the value of `acceptanceFilterBypassCommand`. Subsequent reads from it will return its default value.
  mutating func clearAcceptanceFilterBypassCommand() {_uniqueStorage()._acceptanceFilterBypassCommand = nil}

  var payloadFormatCommand: Openxc_PayloadFormatCommand {
    get {return _storage._payloadFormatCommand ?? Openxc_PayloadFormatCommand()}
    set {_uniqueStorage()._payloadFormatCommand = newValue}
  }
  /// Returns true if `payloadFormatCommand` has been explicitly set.
  var hasPayloadFormatCommand: Bool {return _storage._payloadFormatCommand != nil}
  /// Clears the value of `payloadFormatCommand`. Subsequent reads from it will return its default value.
  mutating func clearPayloadFormatCommand() {_uniqueStorage()._payloadFormatCommand = nil}

  var predefinedObd2RequestsCommand: Openxc_PredefinedObd2RequestsCommand {
    get {return _storage._predefinedObd2RequestsCommand ?? Openxc_PredefinedObd2RequestsCommand()}
    set {_uniqueStorage()._predefinedObd2RequestsCommand = newValue}
  }
  /// Returns true if `predefinedObd2RequestsCommand` has been explicitly set.
  var hasPredefinedObd2RequestsCommand: Bool {return _storage._predefinedObd2RequestsCommand != nil}
  /// Clears the value of `predefinedObd2RequestsCommand`. Subsequent reads from it will return its default value.
  mutating func clearPredefinedObd2RequestsCommand() {_uniqueStorage()._predefinedObd2RequestsCommand = nil}

  var modemConfigurationCommand: Openxc_ModemConfigurationCommand {
    get {return _storage._modemConfigurationCommand ?? Openxc_ModemConfigurationCommand()}
    set {_uniqueStorage()._modemConfigurationCommand = newValue}
  }
  /// Returns true if `modemConfigurationCommand` has been explicitly set.
  var hasModemConfigurationCommand: Bool {return _storage._modemConfigurationCommand != nil}
  /// Clears the value of `modemConfigurationCommand`. Subsequent reads from it will return its default value.
  mutating func clearModemConfigurationCommand() {_uniqueStorage()._modemConfigurationCommand = nil}

  var rtcConfigurationCommand: Openxc_RTCConfigurationCommand {
    get {return _storage._rtcConfigurationCommand ?? Openxc_RTCConfigurationCommand()}
    set {_uniqueStorage()._rtcConfigurationCommand = newValue}
  }
  /// Returns true if `rtcConfigurationCommand` has been explicitly set.
  var hasRtcConfigurationCommand: Bool {return _storage._rtcConfigurationCommand != nil}
  /// Clears the value of `rtcConfigurationCommand`. Subsequent reads from it will return its default value.
  mutating func clearRtcConfigurationCommand() {_uniqueStorage()._rtcConfigurationCommand = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unused // = 0
    case version // = 1
    case deviceID // = 2
    case diagnostic // = 3
    case passthrough // = 4
    case acceptanceFilterBypass // = 5
    case payloadFormat // = 6
    case predefinedObd2Requests // = 7
    case modemConfiguration // = 8
    case rtcConfiguration // = 9
    case sdMountStatus // = 10
    case platform // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .unused
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unused
      case 1: self = .version
      case 2: self = .deviceID
      case 3: self = .diagnostic
      case 4: self = .passthrough
      case 5: self = .acceptanceFilterBypass
      case 6: self = .payloadFormat
      case 7: self = .predefinedObd2Requests
      case 8: self = .modemConfiguration
      case 9: self = .rtcConfiguration
      case 10: self = .sdMountStatus
      case 11: self = .platform
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unused: return 0
      case .version: return 1
      case .deviceID: return 2
      case .diagnostic: return 3
      case .passthrough: return 4
      case .acceptanceFilterBypass: return 5
      case .payloadFormat: return 6
      case .predefinedObd2Requests: return 7
      case .modemConfiguration: return 8
      case .rtcConfiguration: return 9
      case .sdMountStatus: return 10
      case .platform: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Openxc_ControlCommand.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_ControlCommand.TypeEnum] = [
    .unused,
    .version,
    .deviceID,
    .diagnostic,
    .passthrough,
    .acceptanceFilterBypass,
    .payloadFormat,
    .predefinedObd2Requests,
    .modemConfiguration,
    .rtcConfiguration,
    .sdMountStatus,
    .platform,
  ]
}

#endif  // swift(>=4.2)

struct Openxc_DiagnosticControlCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Openxc_DiagnosticRequest {
    get {return _request ?? Openxc_DiagnosticRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var action: Openxc_DiagnosticControlCommand.Action = .unused

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unused // = 0
    case add // = 1
    case cancel // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unused
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unused
      case 1: self = .add
      case 2: self = .cancel
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unused: return 0
      case .add: return 1
      case .cancel: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _request: Openxc_DiagnosticRequest? = nil
}

#if swift(>=4.2)

extension Openxc_DiagnosticControlCommand.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_DiagnosticControlCommand.Action] = [
    .unused,
    .add,
    .cancel,
  ]
}

#endif  // swift(>=4.2)

struct Openxc_PassthroughModeControlCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bus: Int32 = 0

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openxc_AcceptanceFilterBypassCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bus: Int32 = 0

  var bypass: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openxc_PayloadFormatCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var format: Openxc_PayloadFormatCommand.PayloadFormat = .unused

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PayloadFormat: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unused // = 0
    case json // = 1
    case protobuf // = 2
    case messagepack // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unused
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unused
      case 1: self = .json
      case 2: self = .protobuf
      case 3: self = .messagepack
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unused: return 0
      case .json: return 1
      case .protobuf: return 2
      case .messagepack: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Openxc_PayloadFormatCommand.PayloadFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_PayloadFormatCommand.PayloadFormat] = [
    .unused,
    .json,
    .protobuf,
    .messagepack,
  ]
}

#endif  // swift(>=4.2)

struct Openxc_PredefinedObd2RequestsCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openxc_NetworkOperatorSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var allowDataRoaming: Bool = false

  var operatorSelectMode: Openxc_NetworkOperatorSettings.OperatorSelectMode = .automatic

  var networkDescriptor: Openxc_NetworkOperatorSettings.NetworkDescriptor {
    get {return _networkDescriptor ?? Openxc_NetworkOperatorSettings.NetworkDescriptor()}
    set {_networkDescriptor = newValue}
  }
  /// Returns true if `networkDescriptor` has been explicitly set.
  var hasNetworkDescriptor: Bool {return self._networkDescriptor != nil}
  /// Clears the value of `networkDescriptor`. Subsequent reads from it will return its default value.
  mutating func clearNetworkDescriptor() {self._networkDescriptor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OperatorSelectMode: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case automatic // = 0
    case manual // = 1
    case deregister // = 2
    case setOnly // = 3
    case manualAutomatic // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .automatic
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .automatic
      case 1: self = .manual
      case 2: self = .deregister
      case 3: self = .setOnly
      case 4: self = .manualAutomatic
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .automatic: return 0
      case .manual: return 1
      case .deregister: return 2
      case .setOnly: return 3
      case .manualAutomatic: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct NetworkDescriptor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var plmn: UInt32 = 0

    var networkType: Openxc_NetworkOperatorSettings.NetworkDescriptor.NetworkType = .gsm

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum NetworkType: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case gsm // = 0
      case utran // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .gsm
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .gsm
        case 2: self = .utran
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .gsm: return 0
        case .utran: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}

  fileprivate var _networkDescriptor: Openxc_NetworkOperatorSettings.NetworkDescriptor? = nil
}

#if swift(>=4.2)

extension Openxc_NetworkOperatorSettings.OperatorSelectMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_NetworkOperatorSettings.OperatorSelectMode] = [
    .automatic,
    .manual,
    .deregister,
    .setOnly,
    .manualAutomatic,
  ]
}

extension Openxc_NetworkOperatorSettings.NetworkDescriptor.NetworkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_NetworkOperatorSettings.NetworkDescriptor.NetworkType] = [
    .gsm,
    .utran,
  ]
}

#endif  // swift(>=4.2)

struct Openxc_NetworkDataSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var apn: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openxc_ServerConnectSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var host: String = String()

  var port: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openxc_ModemConfigurationCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var networkOperatorSettings: Openxc_NetworkOperatorSettings {
    get {return _networkOperatorSettings ?? Openxc_NetworkOperatorSettings()}
    set {_networkOperatorSettings = newValue}
  }
  /// Returns true if `networkOperatorSettings` has been explicitly set.
  var hasNetworkOperatorSettings: Bool {return self._networkOperatorSettings != nil}
  /// Clears the value of `networkOperatorSettings`. Subsequent reads from it will return its default value.
  mutating func clearNetworkOperatorSettings() {self._networkOperatorSettings = nil}

  var networkDataSettings: Openxc_NetworkDataSettings {
    get {return _networkDataSettings ?? Openxc_NetworkDataSettings()}
    set {_networkDataSettings = newValue}
  }
  /// Returns true if `networkDataSettings` has been explicitly set.
  var hasNetworkDataSettings: Bool {return self._networkDataSettings != nil}
  /// Clears the value of `networkDataSettings`. Subsequent reads from it will return its default value.
  mutating func clearNetworkDataSettings() {self._networkDataSettings = nil}

  var serverConnectSettings: Openxc_ServerConnectSettings {
    get {return _serverConnectSettings ?? Openxc_ServerConnectSettings()}
    set {_serverConnectSettings = newValue}
  }
  /// Returns true if `serverConnectSettings` has been explicitly set.
  var hasServerConnectSettings: Bool {return self._serverConnectSettings != nil}
  /// Clears the value of `serverConnectSettings`. Subsequent reads from it will return its default value.
  mutating func clearServerConnectSettings() {self._serverConnectSettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _networkOperatorSettings: Openxc_NetworkOperatorSettings? = nil
  fileprivate var _networkDataSettings: Openxc_NetworkDataSettings? = nil
  fileprivate var _serverConnectSettings: Openxc_ServerConnectSettings? = nil
}

struct Openxc_RTCConfigurationCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unixTime: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openxc_CommandResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Openxc_ControlCommand.TypeEnum = .unused

  var message: String = String()

  var status: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openxc_DiagnosticRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bus: Int32 = 0

  var messageID: UInt32 = 0

  var mode: UInt32 = 0

  var pid: UInt32 = 0

  var payload: Data = Data()

  var multipleResponses: Bool = false

  var frequency: Double = 0

  var name: String = String()

  var decodedType: Openxc_DiagnosticRequest.DecodedType = .unused

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum DecodedType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unused // = 0
    case none // = 1
    case obd2 // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unused
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unused
      case 1: self = .none
      case 2: self = .obd2
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unused: return 0
      case .none: return 1
      case .obd2: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Openxc_DiagnosticRequest.DecodedType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_DiagnosticRequest.DecodedType] = [
    .unused,
    .none,
    .obd2,
  ]
}

#endif  // swift(>=4.2)

struct Openxc_DiagnosticResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bus: Int32 = 0

  var messageID: UInt32 = 0

  var mode: UInt32 = 0

  var pid: UInt32 = 0

  var success: Bool = false

  var negativeResponseCode: UInt32 = 0

  var payload: Data = Data()

  var value: Openxc_DynamicField {
    get {return _value ?? Openxc_DynamicField()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Openxc_DynamicField? = nil
}

struct Openxc_DiagnosticStitchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bus: Int32 = 0

  var messageID: UInt32 = 0

  var mode: UInt32 = 0

  var pid: UInt32 = 0

  var success: Bool = false

  var negativeResponseCode: UInt32 = 0

  var payload: Data = Data()

  var value: Openxc_DynamicField {
    get {return _value ?? Openxc_DynamicField()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var frame: Int32 = 0

  var totalSize: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Openxc_DynamicField? = nil
}

struct Openxc_DynamicField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Openxc_DynamicField.TypeEnum = .unused

  var stringValue: String = String()

  var numericValue: Double = 0

  var booleanValue: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unused // = 0
    case string // = 1
    case num // = 2
    case bool // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unused
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unused
      case 1: self = .string
      case 2: self = .num
      case 3: self = .bool
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unused: return 0
      case .string: return 1
      case .num: return 2
      case .bool: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Openxc_DynamicField.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Openxc_DynamicField.TypeEnum] = [
    .unused,
    .string,
    .num,
    .bool,
  ]
}

#endif  // swift(>=4.2)

struct Openxc_SimpleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var value: Openxc_DynamicField {
    get {return _value ?? Openxc_DynamicField()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var event: Openxc_DynamicField {
    get {return _event ?? Openxc_DynamicField()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  mutating func clearEvent() {self._event = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _value: Openxc_DynamicField? = nil
  fileprivate var _event: Openxc_DynamicField? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "openxc"

extension Openxc_VehicleMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "can_message"),
    3: .standard(proto: "simple_message"),
    4: .standard(proto: "diagnostic_response"),
    5: .standard(proto: "control_command"),
    6: .standard(proto: "command_response"),
    7: .standard(proto: "diagnostic_stitch_response"),
    8: .same(proto: "timestamp"),
  ]

  fileprivate class _StorageClass {
    var _type: Openxc_VehicleMessage.TypeEnum = .unused
    var _canMessage: Openxc_CanMessage? = nil
    var _simpleMessage: Openxc_SimpleMessage? = nil
    var _diagnosticResponse: Openxc_DiagnosticResponse? = nil
    var _controlCommand: Openxc_ControlCommand? = nil
    var _commandResponse: Openxc_CommandResponse? = nil
    var _diagnosticStitchResponse: Openxc_DiagnosticStitchResponse? = nil
    var _timestamp: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _canMessage = source._canMessage
      _simpleMessage = source._simpleMessage
      _diagnosticResponse = source._diagnosticResponse
      _controlCommand = source._controlCommand
      _commandResponse = source._commandResponse
      _diagnosticStitchResponse = source._diagnosticStitchResponse
      _timestamp = source._timestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._canMessage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._simpleMessage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._diagnosticResponse) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._controlCommand) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._commandResponse) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._diagnosticStitchResponse) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .unused {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._canMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._simpleMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._diagnosticResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._controlCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._commandResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._diagnosticStitchResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestamp, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_VehicleMessage, rhs: Openxc_VehicleMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._canMessage != rhs_storage._canMessage {return false}
        if _storage._simpleMessage != rhs_storage._simpleMessage {return false}
        if _storage._diagnosticResponse != rhs_storage._diagnosticResponse {return false}
        if _storage._controlCommand != rhs_storage._controlCommand {return false}
        if _storage._commandResponse != rhs_storage._commandResponse {return false}
        if _storage._diagnosticStitchResponse != rhs_storage._diagnosticStitchResponse {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_VehicleMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED"),
    1: .same(proto: "CAN"),
    2: .same(proto: "SIMPLE"),
    3: .same(proto: "DIAGNOSTIC"),
    4: .same(proto: "CONTROL_COMMAND"),
    5: .same(proto: "COMMAND_RESPONSE"),
    6: .same(proto: "DIAGNOSTIC_STITCH"),
  ]
}

extension Openxc_CanMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CanMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bus"),
    2: .same(proto: "id"),
    3: .same(proto: "data"),
    4: .standard(proto: "frame_format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.bus) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.frameFormat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bus != 0 {
      try visitor.visitSingularInt32Field(value: self.bus, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if self.frameFormat != .unused {
      try visitor.visitSingularEnumField(value: self.frameFormat, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_CanMessage, rhs: Openxc_CanMessage) -> Bool {
    if lhs.bus != rhs.bus {return false}
    if lhs.id != rhs.id {return false}
    if lhs.data != rhs.data {return false}
    if lhs.frameFormat != rhs.frameFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_CanMessage.FrameFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED"),
    1: .same(proto: "STANDARD"),
    2: .same(proto: "EXTENDED"),
  ]
}

extension Openxc_ControlCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ControlCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "diagnostic_request"),
    3: .standard(proto: "passthrough_mode_request"),
    4: .standard(proto: "acceptance_filter_bypass_command"),
    5: .standard(proto: "payload_format_command"),
    6: .standard(proto: "predefined_obd2_requests_command"),
    7: .standard(proto: "modem_configuration_command"),
    8: .standard(proto: "rtc_configuration_command"),
  ]

  fileprivate class _StorageClass {
    var _type: Openxc_ControlCommand.TypeEnum = .unused
    var _diagnosticRequest: Openxc_DiagnosticControlCommand? = nil
    var _passthroughModeRequest: Openxc_PassthroughModeControlCommand? = nil
    var _acceptanceFilterBypassCommand: Openxc_AcceptanceFilterBypassCommand? = nil
    var _payloadFormatCommand: Openxc_PayloadFormatCommand? = nil
    var _predefinedObd2RequestsCommand: Openxc_PredefinedObd2RequestsCommand? = nil
    var _modemConfigurationCommand: Openxc_ModemConfigurationCommand? = nil
    var _rtcConfigurationCommand: Openxc_RTCConfigurationCommand? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _diagnosticRequest = source._diagnosticRequest
      _passthroughModeRequest = source._passthroughModeRequest
      _acceptanceFilterBypassCommand = source._acceptanceFilterBypassCommand
      _payloadFormatCommand = source._payloadFormatCommand
      _predefinedObd2RequestsCommand = source._predefinedObd2RequestsCommand
      _modemConfigurationCommand = source._modemConfigurationCommand
      _rtcConfigurationCommand = source._rtcConfigurationCommand
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._diagnosticRequest) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._passthroughModeRequest) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._acceptanceFilterBypassCommand) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._payloadFormatCommand) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._predefinedObd2RequestsCommand) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._modemConfigurationCommand) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._rtcConfigurationCommand) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .unused {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._diagnosticRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._passthroughModeRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._acceptanceFilterBypassCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._payloadFormatCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._predefinedObd2RequestsCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._modemConfigurationCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._rtcConfigurationCommand {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_ControlCommand, rhs: Openxc_ControlCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._diagnosticRequest != rhs_storage._diagnosticRequest {return false}
        if _storage._passthroughModeRequest != rhs_storage._passthroughModeRequest {return false}
        if _storage._acceptanceFilterBypassCommand != rhs_storage._acceptanceFilterBypassCommand {return false}
        if _storage._payloadFormatCommand != rhs_storage._payloadFormatCommand {return false}
        if _storage._predefinedObd2RequestsCommand != rhs_storage._predefinedObd2RequestsCommand {return false}
        if _storage._modemConfigurationCommand != rhs_storage._modemConfigurationCommand {return false}
        if _storage._rtcConfigurationCommand != rhs_storage._rtcConfigurationCommand {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_ControlCommand.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED"),
    1: .same(proto: "VERSION"),
    2: .same(proto: "DEVICE_ID"),
    3: .same(proto: "DIAGNOSTIC"),
    4: .same(proto: "PASSTHROUGH"),
    5: .same(proto: "ACCEPTANCE_FILTER_BYPASS"),
    6: .same(proto: "PAYLOAD_FORMAT"),
    7: .same(proto: "PREDEFINED_OBD2_REQUESTS"),
    8: .same(proto: "MODEM_CONFIGURATION"),
    9: .same(proto: "RTC_CONFIGURATION"),
    10: .same(proto: "SD_MOUNT_STATUS"),
    11: .same(proto: "PLATFORM"),
  ]
}

extension Openxc_DiagnosticControlCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiagnosticControlCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.action != .unused {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_DiagnosticControlCommand, rhs: Openxc_DiagnosticControlCommand) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_DiagnosticControlCommand.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED"),
    1: .same(proto: "ADD"),
    2: .same(proto: "CANCEL"),
  ]
}

extension Openxc_PassthroughModeControlCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PassthroughModeControlCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bus"),
    2: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.bus) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bus != 0 {
      try visitor.visitSingularInt32Field(value: self.bus, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_PassthroughModeControlCommand, rhs: Openxc_PassthroughModeControlCommand) -> Bool {
    if lhs.bus != rhs.bus {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_AcceptanceFilterBypassCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcceptanceFilterBypassCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bus"),
    2: .same(proto: "bypass"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.bus) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.bypass) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bus != 0 {
      try visitor.visitSingularInt32Field(value: self.bus, fieldNumber: 1)
    }
    if self.bypass != false {
      try visitor.visitSingularBoolField(value: self.bypass, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_AcceptanceFilterBypassCommand, rhs: Openxc_AcceptanceFilterBypassCommand) -> Bool {
    if lhs.bus != rhs.bus {return false}
    if lhs.bypass != rhs.bypass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_PayloadFormatCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PayloadFormatCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.format != .unused {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_PayloadFormatCommand, rhs: Openxc_PayloadFormatCommand) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_PayloadFormatCommand.PayloadFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED"),
    1: .same(proto: "JSON"),
    2: .same(proto: "PROTOBUF"),
    3: .same(proto: "MESSAGEPACK"),
  ]
}

extension Openxc_PredefinedObd2RequestsCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PredefinedObd2RequestsCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_PredefinedObd2RequestsCommand, rhs: Openxc_PredefinedObd2RequestsCommand) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_NetworkOperatorSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkOperatorSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allowDataRoaming"),
    2: .same(proto: "operatorSelectMode"),
    3: .same(proto: "networkDescriptor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.allowDataRoaming) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operatorSelectMode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._networkDescriptor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.allowDataRoaming != false {
      try visitor.visitSingularBoolField(value: self.allowDataRoaming, fieldNumber: 1)
    }
    if self.operatorSelectMode != .automatic {
      try visitor.visitSingularEnumField(value: self.operatorSelectMode, fieldNumber: 2)
    }
    if let v = self._networkDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_NetworkOperatorSettings, rhs: Openxc_NetworkOperatorSettings) -> Bool {
    if lhs.allowDataRoaming != rhs.allowDataRoaming {return false}
    if lhs.operatorSelectMode != rhs.operatorSelectMode {return false}
    if lhs._networkDescriptor != rhs._networkDescriptor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_NetworkOperatorSettings.OperatorSelectMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTOMATIC"),
    1: .same(proto: "MANUAL"),
    2: .same(proto: "DEREGISTER"),
    3: .same(proto: "SET_ONLY"),
    4: .same(proto: "MANUAL_AUTOMATIC"),
  ]
}

extension Openxc_NetworkOperatorSettings.NetworkDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Openxc_NetworkOperatorSettings.protoMessageName + ".NetworkDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PLMN"),
    2: .same(proto: "networkType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.plmn) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.networkType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.plmn != 0 {
      try visitor.visitSingularUInt32Field(value: self.plmn, fieldNumber: 1)
    }
    if self.networkType != .gsm {
      try visitor.visitSingularEnumField(value: self.networkType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_NetworkOperatorSettings.NetworkDescriptor, rhs: Openxc_NetworkOperatorSettings.NetworkDescriptor) -> Bool {
    if lhs.plmn != rhs.plmn {return false}
    if lhs.networkType != rhs.networkType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_NetworkOperatorSettings.NetworkDescriptor.NetworkType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GSM"),
    2: .same(proto: "UTRAN"),
  ]
}

extension Openxc_NetworkDataSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkDataSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.apn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apn.isEmpty {
      try visitor.visitSingularStringField(value: self.apn, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_NetworkDataSettings, rhs: Openxc_NetworkDataSettings) -> Bool {
    if lhs.apn != rhs.apn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_ServerConnectSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerConnectSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_ServerConnectSettings, rhs: Openxc_ServerConnectSettings) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_ModemConfigurationCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModemConfigurationCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "networkOperatorSettings"),
    2: .same(proto: "networkDataSettings"),
    3: .same(proto: "serverConnectSettings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._networkOperatorSettings) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._networkDataSettings) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serverConnectSettings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._networkOperatorSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._networkDataSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._serverConnectSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_ModemConfigurationCommand, rhs: Openxc_ModemConfigurationCommand) -> Bool {
    if lhs._networkOperatorSettings != rhs._networkOperatorSettings {return false}
    if lhs._networkDataSettings != rhs._networkDataSettings {return false}
    if lhs._serverConnectSettings != rhs._serverConnectSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_RTCConfigurationCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RTCConfigurationCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unix_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.unixTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unixTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.unixTime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_RTCConfigurationCommand, rhs: Openxc_RTCConfigurationCommand) -> Bool {
    if lhs.unixTime != rhs.unixTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_CommandResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommandResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "message"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unused {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_CommandResponse, rhs: Openxc_CommandResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_DiagnosticRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiagnosticRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bus"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "mode"),
    4: .same(proto: "pid"),
    5: .same(proto: "payload"),
    6: .standard(proto: "multiple_responses"),
    7: .same(proto: "frequency"),
    8: .same(proto: "name"),
    9: .standard(proto: "decoded_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.bus) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.pid) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.multipleResponses) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.frequency) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.decodedType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bus != 0 {
      try visitor.visitSingularInt32Field(value: self.bus, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageID, fieldNumber: 2)
    }
    if self.mode != 0 {
      try visitor.visitSingularUInt32Field(value: self.mode, fieldNumber: 3)
    }
    if self.pid != 0 {
      try visitor.visitSingularUInt32Field(value: self.pid, fieldNumber: 4)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 5)
    }
    if self.multipleResponses != false {
      try visitor.visitSingularBoolField(value: self.multipleResponses, fieldNumber: 6)
    }
    if self.frequency != 0 {
      try visitor.visitSingularDoubleField(value: self.frequency, fieldNumber: 7)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 8)
    }
    if self.decodedType != .unused {
      try visitor.visitSingularEnumField(value: self.decodedType, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_DiagnosticRequest, rhs: Openxc_DiagnosticRequest) -> Bool {
    if lhs.bus != rhs.bus {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.multipleResponses != rhs.multipleResponses {return false}
    if lhs.frequency != rhs.frequency {return false}
    if lhs.name != rhs.name {return false}
    if lhs.decodedType != rhs.decodedType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_DiagnosticRequest.DecodedType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED"),
    1: .same(proto: "NONE"),
    2: .same(proto: "OBD2"),
  ]
}

extension Openxc_DiagnosticResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiagnosticResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bus"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "mode"),
    4: .same(proto: "pid"),
    5: .same(proto: "success"),
    6: .standard(proto: "negative_response_code"),
    7: .same(proto: "payload"),
    8: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.bus) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.pid) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.negativeResponseCode) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bus != 0 {
      try visitor.visitSingularInt32Field(value: self.bus, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageID, fieldNumber: 2)
    }
    if self.mode != 0 {
      try visitor.visitSingularUInt32Field(value: self.mode, fieldNumber: 3)
    }
    if self.pid != 0 {
      try visitor.visitSingularUInt32Field(value: self.pid, fieldNumber: 4)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 5)
    }
    if self.negativeResponseCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.negativeResponseCode, fieldNumber: 6)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 7)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_DiagnosticResponse, rhs: Openxc_DiagnosticResponse) -> Bool {
    if lhs.bus != rhs.bus {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.success != rhs.success {return false}
    if lhs.negativeResponseCode != rhs.negativeResponseCode {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_DiagnosticStitchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DiagnosticStitchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bus"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "mode"),
    4: .same(proto: "pid"),
    5: .same(proto: "success"),
    6: .standard(proto: "negative_response_code"),
    7: .same(proto: "payload"),
    8: .same(proto: "value"),
    9: .same(proto: "frame"),
    10: .standard(proto: "total_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.bus) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.pid) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.negativeResponseCode) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.frame) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bus != 0 {
      try visitor.visitSingularInt32Field(value: self.bus, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt32Field(value: self.messageID, fieldNumber: 2)
    }
    if self.mode != 0 {
      try visitor.visitSingularUInt32Field(value: self.mode, fieldNumber: 3)
    }
    if self.pid != 0 {
      try visitor.visitSingularUInt32Field(value: self.pid, fieldNumber: 4)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 5)
    }
    if self.negativeResponseCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.negativeResponseCode, fieldNumber: 6)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 7)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.frame != 0 {
      try visitor.visitSingularInt32Field(value: self.frame, fieldNumber: 9)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_DiagnosticStitchResponse, rhs: Openxc_DiagnosticStitchResponse) -> Bool {
    if lhs.bus != rhs.bus {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.pid != rhs.pid {return false}
    if lhs.success != rhs.success {return false}
    if lhs.negativeResponseCode != rhs.negativeResponseCode {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs._value != rhs._value {return false}
    if lhs.frame != rhs.frame {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_DynamicField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DynamicField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "string_value"),
    3: .standard(proto: "numeric_value"),
    4: .standard(proto: "boolean_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stringValue) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.numericValue) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.booleanValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unused {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.stringValue.isEmpty {
      try visitor.visitSingularStringField(value: self.stringValue, fieldNumber: 2)
    }
    if self.numericValue != 0 {
      try visitor.visitSingularDoubleField(value: self.numericValue, fieldNumber: 3)
    }
    if self.booleanValue != false {
      try visitor.visitSingularBoolField(value: self.booleanValue, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_DynamicField, rhs: Openxc_DynamicField) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.stringValue != rhs.stringValue {return false}
    if lhs.numericValue != rhs.numericValue {return false}
    if lhs.booleanValue != rhs.booleanValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openxc_DynamicField.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNUSED"),
    1: .same(proto: "STRING"),
    2: .same(proto: "NUM"),
    3: .same(proto: "BOOL"),
  ]
}

extension Openxc_SimpleMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    3: .same(proto: "event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openxc_SimpleMessage, rhs: Openxc_SimpleMessage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._value != rhs._value {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
